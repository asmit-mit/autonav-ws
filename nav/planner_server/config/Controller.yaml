controller_server:
  ros__parameters:
    use_sim_time: False  # Set to True if using simulation
    controller_frequency: 5.0  # [5.0 - 20.0 Hz] Frequency of controller updates
    min_x_velocity_threshold: 0.001  # [0.0 - 0.01] Minimum linear velocity to consider
    # min_y_velocity_threshold: 0.5  # [0.0 - 0.5] Minimum lateral velocity to consider (not used for diff-drive)
    min_theta_velocity_threshold: 0.001  # [0.0 - 0.01] Minimum angular velocity to consider
    failure_tolerance: 0.6  # [0.0 - 1.0] Time (seconds) to tolerate failures before re-planning

    progress_checker_plugin: "progress_checker"  # Plugin for progress checking
    goal_checker_plugins: ["general_goal_checker"]  # Plugins for goal checking
    controller_plugins: ["FollowPath"]  # List of controller plugins to use

    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5  # [0.1 - 1.0 m] Minimum movement radius to consider progress
      movement_time_allowance: 10.0  # [5.0 - 30.0 s] Time to allow movement without progress

    # Goal checker parameters
    general_goal_checker:
      stateful: True  # Keep goal-checking state between checks
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 1.0  # [0.05 - 1.0 m] Distance tolerance for goal
      yaw_goal_tolerance: 1.0  # [0.05 - 1.0 rad] Angular tolerance for goal

    # MPPI parameters
    FollowPath:
      plugin: "nav2_mppi_controller::MPPIController"
      time_steps: 56  # [20 - 100] Number of time steps to predict
      model_dt: 0.05  # [0.02 - 0.1 s] Duration of each time step
      batch_size: 1000  # [500 - 5000] Number of sampled trajectories
      vx_std: 0.2  # [0.1 - 0.5] Standard deviation for linear velocity sampling
      # vy_std: 0.2  # [0.0 - 0.5] Standard deviation for lateral velocity sampling
      wz_std: 0.4  # [0.1 - 1.0] Standard deviation for angular velocity sampling
      vx_max: 0.5  # [0.2 - 1.0 m/s] Maximum forward velocity
      vx_min: -0.35  # [-0.5 - 0.0 m/s] Maximum reverse velocity
      # vy_max: 0.5  # [0.0 - 0.5 m/s] Maximum lateral velocity (not used for diff-drive)
      wz_max: 1.9  # [0.5 - 3.0 rad/s] Maximum angular velocity
      iteration_count: 3  # [1 - 10] Number of iterations for optimization
      prune_distance: 0.5  # [0.5 - 2.0 m] Distance to prune path segments
      transform_tolerance: 0.1  # [0.05 - 0.5 s] Tolerance for transform lookup
      temperature: 0.3  # [0.1 - 1.0] Exploration temperature for sampling
      gamma: 0.015  # [0.01 - 0.05] Discount factor for future costs
      motion_model: "DiffDrive"  # Motion model ("DiffDrive", "Ackermann", etc.)
      visualize: True  # Enable visualization for debugging
      TrajectoryVisualizer:
        trajectory_step: 5  # Step between visualized points
        time_step: 3  # Time interval between visualized trajectories

      critics: ["ConstraintCritic", "GoalCritic", "PathAlignCritic", "PathFollowCritic", "PathAngleCritic", "PreferForwardCritic"]

      # Constraint Critic
      ConstraintCritic:
        enabled: true
        cost_weight: 4.0  # [1.0 - 10.0] Weight for constraint adherence

      # Goal Critic
      GoalCritic:
        enabled: true
        cost_weight: 5.0  # [1.0 - 10.0] Weight for goal alignment
        threshold_to_consider: 1.4  # [0.5 - 2.0 m] Distance threshold to consider goal

      # Path Alignment Critic
      PathAlignCritic:
        enabled: true
        cost_weight: 14.0  # [5.0 - 20.0] Weight for path alignment
        max_path_occupancy_ratio: 0.05  # [0.01 - 0.1] Occupancy threshold
        trajectory_point_step: 4  # Step size for trajectory points
        threshold_to_consider: 0.5  # [0.1 - 1.0 m] Threshold for alignment
        offset_from_furthest: 20  # Number of points to skip from the end
        use_path_orientations: false  # Use path orientations for alignment

      # Path Following Critic
      PathFollowCritic:
        enabled: true
        cost_weight: 5.0  # [1.0 - 10.0] Weight for path following
        offset_from_furthest: 5  # Offset points from the end of the path
        threshold_to_consider: 1.4  # [0.5 - 2.0 m] Threshold to consider path

      # Path Angle Critic
      PathAngleCritic:
        enabled: true
        cost_weight: 2.0  # [1.0 - 5.0] Weight for path angle alignment
        offset_from_furthest: 4  # Offset points from the end of the path
        threshold_to_consider: 0.5  # [0.1 - 1.0 rad] Threshold for angle alignment
        max_angle_to_furthest: 1.0  # Maximum angle to furthest point
        forward_preference: true  # Prefer forward motion

      # Prefer Forward Critic
      PreferForwardCritic:
        enabled: true
        cost_weight: 5.0  # [1.0 - 10.0] Weight for forward preference
        threshold_to_consider: 0.5  # [0.1 - 1.0 m] Threshold for forward preference



local_costmap:
  local_costmap:
    ros__parameters:
      qos_overrides:
        subscription:
          durability: VOLATILE
      update_frequency: 5.0  # [2.0 - 10.0 Hz] Frequency of costmap updates
      publish_frequency: 2.0  # [1.0 - 10.0 Hz] Frequency of costmap publishing
      global_frame: odom  # Frame for costmap
      robot_base_frame: base_link  # Robot's base frame
      use_sim_time: False  # Set to True for simulation
      rolling_window: true  # Use a rolling window for the costmap
      width: 15  # [5.0 - 30.0 m] Width of the local costmap
      height: 15  # [5.0 - 30.0 m] Height of the local costmap
      resolution: 0.06  # [0.02 - 0.1 m] Resolution of the costmap
      robot_radius: 0.35  # [0.1 - 1.0 m] Robot's radius for inflation
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: false
        enabled: true  # Enable static map
        subscribe_to_updates: true  # Update map dynamically

      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True  # Enable obstacle detection
        observation_sources: pointcloud
        pointcloud:
          topic: /lidar/points  # Sensor topic for obstacles
          max_obstacle_height: 2.0  # [0.5 - 3.0 m] Maximum obstacle height
          clearing: true  # Enable clearing for dynamic obstacles
          marking: true  # Enable marking for obstacles
          data_type: "PointCloud2"  # Sensor data type
          raytrace_max_range: 3.0  # [1.0 - 10.0 m] Max raytrace distance
          raytrace_min_range: 0.0  # [0.0 - 1.0 m] Min raytrace distance
          obstacle_max_range: 2.5  # [1.0 - 5.0 m] Max obstacle marking range
          obstacle_min_range: 0.9  # [0.0 - 1.0 m] Min obstacle marking range

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0  # [1.0 - 10.0] Exponential scaling for cost
        inflation_radius: 0.3  # [0.1 - 1.0 m] Radius for obstacle inflation

      always_send_full_costmap: True  # Send full costmap instead of updates
